package realtime

import (
	"encoding/json"
	"testing"
	"time"
)

// readWithTimeout returns the next message from ch or nil if the timeout elapses.
func readWithTimeout(ch <-chan []byte, d time.Duration) []byte {
	select {
	case b := <-ch:
		return b
	case <-time.After(d):
		return nil
	}
}

// setupHubWithClients creates a hub with a sender and receiver client already present in the hub.
func setupHubWithClients(t *testing.T) (*Hub, *Client, *Client) {
	t.Helper()

	h := NewHub()
	go h.Run()

	sender := &Client{
		userID: "sender-1",
		hub:    h,
		conn:   nil,
		send:   make(chan []byte, 10),
	}
	receiver := &Client{
		userID: "receiver-1",
		hub:    h,
		conn:   nil,
		send:   make(chan []byte, 10),
	}

	h.Register(sender)
	h.Register(receiver)

	// Drain the presence update generated by the second registration so it does not
	// interfere with later assertions.
	readWithTimeout(receiver.send, 200*time.Millisecond)

	t.Cleanup(func() {
		h.unregister <- sender
		h.unregister <- receiver
	})

	return h, sender, receiver
}

func TestClient_handleMessage_typingUpdateBroadcastsToOthers(t *testing.T) {
	_, sender, receiver := setupHubWithClients(t)

	payload := map[string]any{
		"type": "typing_update",
		"char": "a",
	}
	data, err := json.Marshal(payload)
	if err != nil {
		t.Fatalf("marshal: %v", err)
	}

	sender.handleMessage(data)

	got := readWithTimeout(receiver.send, 200*time.Millisecond)
	if got == nil {
		t.Fatalf("expected a broadcast message, got none")
	}

	var msg TypingUpdateMessage
	if err := json.Unmarshal(got, &msg); err != nil {
		t.Fatalf("unmarshal broadcast: %v", err)
	}

	if msg.Type != "typing_update" {
		t.Fatalf("expected type typing_update, got %q", msg.Type)
	}
	if msg.UserID != sender.userID {
		t.Fatalf("expected userId %q, got %q", sender.userID, msg.UserID)
	}
	if msg.Char != "a" {
		t.Fatalf("expected char 'a', got %q", msg.Char)
	}
}

func TestClient_handleMessage_typingClearBroadcastsToOthers(t *testing.T) {
	_, sender, receiver := setupHubWithClients(t)

	payload := map[string]any{
		"type": "typing_clear",
	}
	data, err := json.Marshal(payload)
	if err != nil {
		t.Fatalf("marshal: %v", err)
	}

	sender.handleMessage(data)

	got := readWithTimeout(receiver.send, 200*time.Millisecond)
	if got == nil {
		t.Fatalf("expected a broadcast message, got none")
	}

	var msg TypingClearMessage
	if err := json.Unmarshal(got, &msg); err != nil {
		t.Fatalf("unmarshal broadcast: %v", err)
	}

	if msg.Type != "typing_clear" {
		t.Fatalf("expected type typing_clear, got %q", msg.Type)
	}
	if msg.UserID != sender.userID {
		t.Fatalf("expected userId %q, got %q", sender.userID, msg.UserID)
	}
}

func TestClient_handleMessage_unknownTypeDoesNotBroadcast(t *testing.T) {
	_, sender, receiver := setupHubWithClients(t)

	payload := map[string]any{
		"type": "unknown_type",
	}
	data, err := json.Marshal(payload)
	if err != nil {
		t.Fatalf("marshal: %v", err)
	}

	sender.handleMessage(data)

	got := readWithTimeout(receiver.send, 150*time.Millisecond)
	if got != nil {
		t.Fatalf("expected no broadcast, got %s", string(got))
	}
}

func TestClient_handleMessage_invalidJSONDoesNotPanicOrBroadcast(t *testing.T) {
	_, sender, receiver := setupHubWithClients(t)

	// Intentionally invalid JSON
	data := []byte("{invalid json")

	sender.handleMessage(data)

	got := readWithTimeout(receiver.send, 150*time.Millisecond)
	if got != nil {
		t.Fatalf("expected no broadcast, got %s", string(got))
	}
}
